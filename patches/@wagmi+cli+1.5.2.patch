diff --git a/node_modules/@wagmi/cli/dist/plugins/index.d.ts b/node_modules/@wagmi/cli/dist/plugins/index.d.ts
index 04a78d1..e3d0261 100644
--- a/node_modules/@wagmi/cli/dist/plugins/index.d.ts
+++ b/node_modules/@wagmi/cli/dist/plugins/index.d.ts
@@ -114,6 +114,7 @@ declare const apiUrls: {
     1: string;
     5: string;
     11155111: string;
+    11155420: string;
     10: string;
     420: string;
     137: string;
diff --git a/node_modules/@wagmi/cli/dist/plugins/index.js b/node_modules/@wagmi/cli/dist/plugins/index.js
index 8e23da2..98d869d 100644
--- a/node_modules/@wagmi/cli/dist/plugins/index.js
+++ b/node_modules/@wagmi/cli/dist/plugins/index.js
@@ -46,7 +46,8 @@ function actions(config = {}) {
         if (contract.meta.addressName) {
           omitted = `| 'address'`;
           if (typeof contract.address === "object") {
-            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName} }`;
+            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}, address?: Address  }`;
+
             if (Object.keys(contract.address).length > 1) {
               innerActionParams.address = `${contract.meta.addressName}[config.chainId as keyof typeof ${contract.meta.addressName}]`;
             } else
@@ -274,6 +275,7 @@ function actions(config = {}) {
       return {
         imports: importValues.length ? dedent`
             import { ${importValues.join(", ")} } from '${packageName}'
+            import { Address } from 'wagmi'
           ` : "",
         content: content.join("\n\n")
       };
@@ -1383,6 +1385,7 @@ var apiUrls = {
   [11155111]: "https://api-sepolia.etherscan.io/api",
   [10]: "https://api-optimistic.etherscan.io/api",
   [420]: "https://api-goerli-optimistic.etherscan.io/api",
+  [11155420]: "https://api-sepolia-optimistic.etherscan.io/api",
   [137]: "https://api.polygonscan.com/api",
   [80001]: "https://api-testnet.polygonscan.com/api",
   [42161]: "https://api.arbiscan.io/api",
@@ -1764,7 +1767,8 @@ function react(config = {}) {
         if (contract.meta.addressName) {
           omitted = `| 'address'`;
           if (typeof contract.address === "object") {
-            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}  }`;
+            imports.add("Address");
+            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}, address?: Address  }`;
             if (Object.keys(contract.address).length > 1) {
               innerHookParams.address = `${contract.meta.addressName}[chainId as keyof typeof ${contract.meta.addressName}]`;
               imports.add("useNetwork");
diff --git a/node_modules/@wagmi/cli/dist/plugins/index.js.orig b/node_modules/@wagmi/cli/dist/plugins/index.js.orig
new file mode 100644
index 0000000..eaa8429
--- /dev/null
+++ b/node_modules/@wagmi/cli/dist/plugins/index.js.orig
@@ -0,0 +1,2279 @@
+import {
+  fromZodError
+} from "../chunk-4SLKODV3.js";
+import {
+  getAddressDocString,
+  getInstallCommand,
+  getIsPackageInstalled,
+  getPackageManager
+} from "../chunk-PPLSXH24.js";
+import {
+  log
+} from "../chunk-3XEDX7DR.js";
+import "../chunk-UICA3PK6.js";
+
+// src/plugins/actions.ts
+import { pascalCase } from "change-case";
+import dedent from "dedent";
+function actions(config = {}) {
+  const actions2 = {
+    getContract: true,
+    prepareWriteContract: true,
+    readContract: true,
+    watchContractEvent: true,
+    writeContract: true,
+    ...config
+  };
+  return {
+    name: "Core",
+    async run({ contracts, isTypeScript, outputs }) {
+      const imports = /* @__PURE__ */ new Set([]);
+      const hasWriteContractMode = outputs.some(
+        (x) => x.plugin.name === "React" && x.imports?.includes("WriteContractMode")
+      );
+      const actionNames = /* @__PURE__ */ new Set();
+      const getActionNameError = (name, contractName) => new Error(
+        `Action name "${name}" must be unique for contract "${contractName}".`
+      );
+      const content = [];
+      for (const contract of contracts) {
+        const baseActionName = pascalCase(contract.name);
+        let typeParams = "";
+        let omitted = "";
+        const innerActionParams = {
+          abi: contract.meta.abiName
+        };
+        if (contract.meta.addressName) {
+          omitted = `| 'address'`;
+          if (typeof contract.address === "object") {
+            imports.add("Address");
+            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}, address?: Address  }`;
+
+            if (Object.keys(contract.address).length > 1) {
+              innerActionParams.address = `${contract.meta.addressName}[config.chainId as keyof typeof ${contract.meta.addressName}]`;
+            } else
+              innerActionParams.address = `${contract.meta.addressName}[${Object.keys(contract.address)[0]}]`;
+          } else if (contract.address)
+            innerActionParams.address = contract.meta.addressName;
+        }
+        const innerActionConfig = `${Object.entries(innerActionParams).reduce(
+          (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
+          "{"
+        )}...config}`;
+        const genDocString = (actionName, item) => {
+          let description = `Wraps __{@link ${actionName}}__ with \`abi\` set to __{@link ${contract.meta.abiName}}__`;
+          if (item)
+            description += ` and \`${item.name}\` set to \`"${item.value}"\``;
+          if (contract.address) {
+            const docString = getAddressDocString({ address: contract.address });
+            if (docString)
+              return dedent`
+              /**
+              * ${description}.
+              * 
+              ${docString}
+              */
+              `;
+          }
+          return dedent`
+          /**
+           * ${description}.
+           */
+          `;
+        };
+        if (actions2.getContract) {
+          const name = `get${baseActionName}`;
+          if (actionNames.has(name))
+            throw getActionNameError(name, contract.name);
+          actionNames.add(name);
+          imports.add("getContract");
+          const docString = genDocString("getContract");
+          let code;
+          if (isTypeScript) {
+            imports.add("GetContractArgs");
+            code = dedent`
+            ${docString}
+            export function ${name}(
+              config: Omit<GetContractArgs, 'abi'${omitted}>${typeParams},
+            ) {
+              return getContract(${innerActionConfig})
+            }
+            `;
+          } else
+            code = dedent`
+            ${docString}
+            export function ${name}(config) {
+              return getContract(${innerActionConfig})
+            }
+            `;
+          content.push(code);
+        }
+        let hasReadFunction = false;
+        let hasWriteFunction = false;
+        let hasEvent = false;
+        for (const component of contract.abi) {
+          if (component.type === "function")
+            if (component.stateMutability === "view" || component.stateMutability === "pure")
+              hasReadFunction = true;
+            else
+              hasWriteFunction = true;
+          else if (component.type === "event")
+            hasEvent = true;
+          if (hasReadFunction && hasWriteFunction && hasEvent)
+            break;
+        }
+        if (hasReadFunction) {
+          if (actions2.readContract) {
+            const name = `read${baseActionName}`;
+            if (actionNames.has(name))
+              throw getActionNameError(name, contract.name);
+            actionNames.add(name);
+            imports.add("readContract");
+            const docString = genDocString("readContract");
+            let code;
+            if (isTypeScript) {
+              imports.add("ReadContractConfig");
+              code = dedent`
+              ${docString}
+              export function ${name}<
+                TAbi extends readonly unknown[] = typeof ${contract.meta.abiName},
+                TFunctionName extends string = string,
+              >(
+                config: Omit<ReadContractConfig<TAbi, TFunctionName>, 'abi'${omitted}>${typeParams},
+              ) {
+                return readContract(${innerActionConfig} as unknown as ReadContractConfig<TAbi, TFunctionName>)
+              }
+              `;
+            } else
+              code = dedent`
+              ${docString}
+              export function ${name}(config) {
+                return readContract(${innerActionConfig})
+              }
+              `;
+            content.push(code);
+          }
+        }
+        if (hasWriteFunction) {
+          if (actions2.writeContract) {
+            const name = `write${baseActionName}`;
+            if (actionNames.has(name))
+              throw getActionNameError(name, contract.name);
+            actionNames.add(name);
+            imports.add("writeContract");
+            const docString = genDocString("writeContract");
+            let code;
+            if (isTypeScript) {
+              const hasMultichainAddress = typeof contract.address === "object";
+              const TChainId = hasMultichainAddress ? `TMode extends WriteContractMode, TChainId extends number = keyof typeof ${contract.meta.addressName}` : "";
+              let typeParams_ = "";
+              if (TChainId) {
+                if (!hasWriteContractMode)
+                  imports.add("WriteContractMode");
+                typeParams_ = `& { mode: TMode; chainId?: TMode extends 'prepared' ? TChainId : keyof typeof ${contract.meta.addressName} }`;
+              }
+              imports.add("WriteContractArgs");
+              imports.add("WriteContractPreparedArgs");
+              imports.add("WriteContractUnpreparedArgs");
+              code = dedent`
+              ${docString}
+              export function ${name}<
+                TFunctionName extends string,
+                ${TChainId}
+              >(
+                config:
+                  | (Omit<WriteContractPreparedArgs<typeof ${contract.meta.abiName}, TFunctionName>, 'abi'${omitted}>${typeParams_})
+                  | (Omit<WriteContractUnpreparedArgs<typeof ${contract.meta.abiName}, TFunctionName>, 'abi'${omitted}>${typeParams_}),
+              ) {
+                return writeContract(${innerActionConfig} as unknown as WriteContractArgs<typeof ${contract.meta.abiName}, TFunctionName>)
+              }
+              `;
+            } else
+              code = dedent`
+              ${docString}
+              export function ${name}(config) {
+                return writeContract(${innerActionConfig})
+              }
+              `;
+            content.push(code);
+          }
+          if (actions2.prepareWriteContract) {
+            const name = `prepareWrite${baseActionName}`;
+            if (actionNames.has(name))
+              throw getActionNameError(name, contract.name);
+            actionNames.add(name);
+            imports.add("prepareWriteContract");
+            const docString = genDocString("prepareWriteContract");
+            let code;
+            if (isTypeScript) {
+              imports.add("PrepareWriteContractConfig");
+              code = dedent`
+              ${docString}
+              export function ${name}<
+                TAbi extends readonly unknown[] = typeof ${contract.meta.abiName},
+                TFunctionName extends string = string,
+              >(
+                config: Omit<PrepareWriteContractConfig<TAbi, TFunctionName>, 'abi'${omitted}>${typeParams},
+              ) {
+                return prepareWriteContract(${innerActionConfig} as unknown as PrepareWriteContractConfig<TAbi, TFunctionName>)
+              }
+              `;
+            } else
+              code = dedent`
+              ${docString}
+              export function ${name}(config) {
+                return prepareWriteContract(${innerActionConfig})
+              }
+              `;
+            content.push(code);
+          }
+        }
+        if (hasEvent) {
+          if (actions2.watchContractEvent) {
+            const name = `watch${baseActionName}Event`;
+            if (actionNames.has(name))
+              throw getActionNameError(name, contract.name);
+            actionNames.add(name);
+            imports.add("watchContractEvent");
+            const docString = genDocString("watchContractEvent");
+            let code;
+            if (isTypeScript) {
+              imports.add("WatchContractEventConfig");
+              imports.add("WatchContractEventCallback");
+              code = dedent`
+              ${docString}
+              export function ${name}<
+                TAbi extends readonly unknown[] = typeof ${contract.meta.abiName},
+                TEventName extends string = string,
+              >(
+                config: Omit<WatchContractEventConfig<TAbi, TEventName>, 'abi'${omitted}>${typeParams},
+                callback: WatchContractEventCallback<TAbi, TEventName>,
+              ) {
+                return watchContractEvent(${innerActionConfig} as WatchContractEventConfig<TAbi, TEventName>, callback)
+              }
+              `;
+            } else
+              code = dedent`
+              ${docString}
+              export function ${name}(config, callback) {
+                return watchContractEvent(${innerActionConfig}, callback)
+              }
+              `;
+            content.push(code);
+          }
+        }
+      }
+      let packageName;
+      if (config.overridePackageName)
+        packageName = config.overridePackageName;
+      else if (await getIsPackageInstalled({ packageName: "wagmi" }))
+        packageName = "wagmi/actions";
+      else if (await getIsPackageInstalled({ packageName: "@wagmi/core" }))
+        packageName = "@wagmi/core";
+      else
+        packageName = "@wagmi/core";
+      const importValues = [...imports.values()];
+      return {
+        imports: importValues.length ? dedent`
+            import { ${importValues.join(", ")} } from '${packageName}'
+          ` : "",
+        content: content.join("\n\n")
+      };
+    }
+  };
+}
+
+// src/plugins/blockExplorer.ts
+import { camelCase } from "change-case";
+import { z } from "zod";
+
+// src/plugins/fetch.ts
+import { default as fse } from "fs-extra";
+import { default as fetch_ } from "node-fetch";
+import { join } from "pathe";
+import { homedir } from "os";
+function fetch({
+  cacheDuration = 18e5,
+  contracts: contractConfigs,
+  getCacheKey = ({ contract }) => JSON.stringify(contract),
+  name = "Fetch",
+  parse = ({ response }) => response.json(),
+  request,
+  timeoutDuration = 5e3
+}) {
+  return {
+    async contracts() {
+      const cacheDir = join(homedir(), ".wagmi-cli/plugins/fetch/cache");
+      await fse.ensureDir(cacheDir);
+      const timestamp = Date.now() + cacheDuration;
+      const contracts = [];
+      for (const contract of contractConfigs) {
+        const cacheKey = getCacheKey({ contract });
+        const cacheFilePath = join(cacheDir, `${cacheKey}.json`);
+        const cachedFile = await fse.readJSON(cacheFilePath).catch(() => null);
+        let abi;
+        if (cachedFile?.timestamp > Date.now())
+          abi = cachedFile.abi;
+        else {
+          const AbortController = globalThis.AbortController || (await import("abort-controller")).default;
+          const controller = new AbortController();
+          const timeout = setTimeout(() => controller.abort(), timeoutDuration);
+          try {
+            const { url, init } = await request(contract);
+            const response = await fetch_(url, {
+              ...init,
+              signal: controller.signal
+            });
+            abi = await parse({ response });
+            await fse.writeJSON(cacheFilePath, { abi, timestamp });
+          } catch (error) {
+            try {
+              abi = (await fse.readJSON(cacheFilePath)).abi;
+            } catch {
+            }
+            if (!abi)
+              throw error;
+          } finally {
+            clearTimeout(timeout);
+          }
+        }
+        contracts.push({ abi, address: contract.address, name: contract.name });
+      }
+      return contracts;
+    },
+    name
+  };
+}
+
+// src/plugins/blockExplorer.ts
+var BlockExplorerResponse = z.discriminatedUnion("status", [
+  z.object({
+    status: z.literal("1"),
+    message: z.literal("OK"),
+    result: z.string().transform((val) => JSON.parse(val))
+  }),
+  z.object({
+    status: z.literal("0"),
+    message: z.literal("NOTOK"),
+    result: z.string()
+  })
+]);
+function blockExplorer({
+  apiKey,
+  baseUrl,
+  cacheDuration,
+  contracts,
+  getAddress = ({ address }) => {
+    if (typeof address === "string")
+      return address;
+    return Object.values(address)[0];
+  },
+  name = "Block Explorer"
+}) {
+  return fetch({
+    cacheDuration,
+    contracts,
+    name,
+    getCacheKey({ contract }) {
+      if (typeof contract.address === "string")
+        return `${camelCase(name)}:${contract.address}`;
+      return `${camelCase(name)}:${JSON.stringify(contract.address)}`;
+    },
+    async parse({ response }) {
+      const json = await response.json();
+      const parsed = await BlockExplorerResponse.safeParseAsync(json);
+      if (!parsed.success)
+        throw fromZodError(parsed.error, { prefix: "Invalid response" });
+      if (parsed.data.status === "0")
+        throw new Error(parsed.data.result);
+      return parsed.data.result;
+    },
+    request({ address }) {
+      if (!address)
+        throw new Error("address is required");
+      return {
+        url: `${baseUrl}?module=contract&action=getabi&address=${getAddress({
+          address
+        })}${apiKey ? `&apikey=${apiKey}` : ""}`
+      };
+    }
+  });
+}
+
+// src/plugins/erc.ts
+var erc20ABI = [
+  {
+    type: "event",
+    name: "Approval",
+    inputs: [
+      {
+        indexed: true,
+        name: "owner",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "spender",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "value",
+        type: "uint256"
+      }
+    ]
+  },
+  {
+    type: "event",
+    name: "Transfer",
+    inputs: [
+      {
+        indexed: true,
+        name: "from",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "to",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "value",
+        type: "uint256"
+      }
+    ]
+  },
+  {
+    type: "function",
+    name: "allowance",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "owner",
+        type: "address"
+      },
+      {
+        name: "spender",
+        type: "address"
+      }
+    ],
+    outputs: [{ type: "uint256" }]
+  },
+  {
+    type: "function",
+    name: "approve",
+    stateMutability: "nonpayable",
+    inputs: [
+      {
+        name: "spender",
+        type: "address"
+      },
+      {
+        name: "amount",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "bool" }]
+  },
+  {
+    type: "function",
+    name: "balanceOf",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "account",
+        type: "address"
+      }
+    ],
+    outputs: [{ type: "uint256" }]
+  },
+  {
+    type: "function",
+    name: "decimals",
+    stateMutability: "view",
+    inputs: [],
+    outputs: [{ type: "uint8" }]
+  },
+  {
+    type: "function",
+    name: "name",
+    stateMutability: "view",
+    inputs: [],
+    outputs: [{ type: "string" }]
+  },
+  {
+    type: "function",
+    name: "symbol",
+    stateMutability: "view",
+    inputs: [],
+    outputs: [{ type: "string" }]
+  },
+  {
+    type: "function",
+    name: "totalSupply",
+    stateMutability: "view",
+    inputs: [],
+    outputs: [{ type: "uint256" }]
+  },
+  {
+    type: "function",
+    name: "transfer",
+    stateMutability: "nonpayable",
+    inputs: [
+      {
+        name: "recipient",
+        type: "address"
+      },
+      {
+        name: "amount",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "bool" }]
+  },
+  {
+    type: "function",
+    name: "transferFrom",
+    stateMutability: "nonpayable",
+    inputs: [
+      {
+        name: "sender",
+        type: "address"
+      },
+      {
+        name: "recipient",
+        type: "address"
+      },
+      {
+        name: "amount",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "bool" }]
+  },
+  {
+    type: "function",
+    name: "increaseAllowance",
+    stateMutability: "nonpayable",
+    inputs: [
+      {
+        name: "spender",
+        type: "address"
+      },
+      {
+        name: "addedValue",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "bool" }]
+  },
+  {
+    type: "function",
+    name: "decreaseAllowance",
+    stateMutability: "nonpayable",
+    inputs: [
+      {
+        name: "spender",
+        type: "address"
+      },
+      {
+        name: "subtractedValue",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "bool" }]
+  }
+];
+var erc721ABI = [
+  {
+    type: "event",
+    name: "Approval",
+    inputs: [
+      {
+        indexed: true,
+        name: "owner",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "spender",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "tokenId",
+        type: "uint256"
+      }
+    ]
+  },
+  {
+    type: "event",
+    name: "ApprovalForAll",
+    inputs: [
+      {
+        indexed: true,
+        name: "owner",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "operator",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "approved",
+        type: "bool"
+      }
+    ]
+  },
+  {
+    type: "event",
+    name: "Transfer",
+    inputs: [
+      {
+        indexed: true,
+        name: "from",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "to",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "tokenId",
+        type: "uint256"
+      }
+    ]
+  },
+  {
+    type: "function",
+    name: "approve",
+    stateMutability: "payable",
+    inputs: [
+      {
+        name: "spender",
+        type: "address"
+      },
+      {
+        name: "tokenId",
+        type: "uint256"
+      }
+    ],
+    outputs: []
+  },
+  {
+    type: "function",
+    name: "balanceOf",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "account",
+        type: "address"
+      }
+    ],
+    outputs: [{ type: "uint256" }]
+  },
+  {
+    type: "function",
+    name: "getApproved",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "tokenId",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "address" }]
+  },
+  {
+    type: "function",
+    name: "isApprovedForAll",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "owner",
+        type: "address"
+      },
+      {
+        name: "operator",
+        type: "address"
+      }
+    ],
+    outputs: [{ type: "bool" }]
+  },
+  {
+    type: "function",
+    name: "name",
+    stateMutability: "view",
+    inputs: [],
+    outputs: [{ type: "string" }]
+  },
+  {
+    type: "function",
+    name: "ownerOf",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "tokenId",
+        type: "uint256"
+      }
+    ],
+    outputs: [
+      {
+        name: "owner",
+        type: "address"
+      }
+    ]
+  },
+  {
+    type: "function",
+    name: "safeTransferFrom",
+    stateMutability: "payable",
+    inputs: [
+      {
+        name: "from",
+        type: "address"
+      },
+      {
+        name: "to",
+        type: "address"
+      },
+      {
+        name: "tokenId",
+        type: "uint256"
+      }
+    ],
+    outputs: []
+  },
+  {
+    type: "function",
+    name: "safeTransferFrom",
+    stateMutability: "nonpayable",
+    inputs: [
+      {
+        name: "from",
+        type: "address"
+      },
+      {
+        name: "to",
+        type: "address"
+      },
+      {
+        name: "id",
+        type: "uint256"
+      },
+      {
+        name: "data",
+        type: "bytes"
+      }
+    ],
+    outputs: []
+  },
+  {
+    type: "function",
+    name: "setApprovalForAll",
+    stateMutability: "nonpayable",
+    inputs: [
+      {
+        name: "operator",
+        type: "address"
+      },
+      {
+        name: "approved",
+        type: "bool"
+      }
+    ],
+    outputs: []
+  },
+  {
+    type: "function",
+    name: "symbol",
+    stateMutability: "view",
+    inputs: [],
+    outputs: [{ type: "string" }]
+  },
+  {
+    type: "function",
+    name: "tokenByIndex",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "index",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "uint256" }]
+  },
+  {
+    type: "function",
+    name: "tokenByIndex",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "owner",
+        type: "address"
+      },
+      {
+        name: "index",
+        type: "uint256"
+      }
+    ],
+    outputs: [
+      {
+        name: "tokenId",
+        type: "uint256"
+      }
+    ]
+  },
+  {
+    type: "function",
+    name: "tokenURI",
+    stateMutability: "view",
+    inputs: [
+      {
+        name: "tokenId",
+        type: "uint256"
+      }
+    ],
+    outputs: [{ type: "string" }]
+  },
+  {
+    type: "function",
+    name: "totalSupply",
+    stateMutability: "view",
+    inputs: [],
+    outputs: [{ type: "uint256" }]
+  },
+  {
+    type: "function",
+    name: "transferFrom",
+    stateMutability: "payable",
+    inputs: [
+      {
+        name: "sender",
+        type: "address"
+      },
+      {
+        name: "recipient",
+        type: "address"
+      },
+      {
+        name: "tokenId",
+        type: "uint256"
+      }
+    ],
+    outputs: []
+  }
+];
+var erc4626ABI = [
+  {
+    anonymous: false,
+    inputs: [
+      {
+        indexed: true,
+        name: "owner",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "spender",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "value",
+        type: "uint256"
+      }
+    ],
+    name: "Approval",
+    type: "event"
+  },
+  {
+    anonymous: false,
+    inputs: [
+      {
+        indexed: true,
+        name: "sender",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "receiver",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "assets",
+        type: "uint256"
+      },
+      {
+        indexed: false,
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    name: "Deposit",
+    type: "event"
+  },
+  {
+    anonymous: false,
+    inputs: [
+      {
+        indexed: true,
+        name: "from",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "to",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "value",
+        type: "uint256"
+      }
+    ],
+    name: "Transfer",
+    type: "event"
+  },
+  {
+    anonymous: false,
+    inputs: [
+      {
+        indexed: true,
+        name: "sender",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "receiver",
+        type: "address"
+      },
+      {
+        indexed: true,
+        name: "owner",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "assets",
+        type: "uint256"
+      },
+      {
+        indexed: false,
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    name: "Withdraw",
+    type: "event"
+  },
+  {
+    inputs: [
+      {
+        name: "owner",
+        type: "address"
+      },
+      {
+        name: "spender",
+        type: "address"
+      }
+    ],
+    name: "allowance",
+    outputs: [{ type: "uint256" }],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "spender",
+        type: "address"
+      },
+      {
+        name: "amount",
+        type: "uint256"
+      }
+    ],
+    name: "approve",
+    outputs: [{ type: "bool" }],
+    stateMutability: "nonpayable",
+    type: "function"
+  },
+  {
+    inputs: [],
+    name: "asset",
+    outputs: [
+      {
+        name: "assetTokenAddress",
+        type: "address"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "account",
+        type: "address"
+      }
+    ],
+    name: "balanceOf",
+    outputs: [{ type: "uint256" }],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    name: "convertToAssets",
+    outputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    name: "convertToShares",
+    outputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      },
+      {
+        name: "receiver",
+        type: "address"
+      }
+    ],
+    name: "deposit",
+    outputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "nonpayable",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "caller",
+        type: "address"
+      }
+    ],
+    name: "maxDeposit",
+    outputs: [
+      {
+        name: "maxAssets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "caller",
+        type: "address"
+      }
+    ],
+    name: "maxMint",
+    outputs: [
+      {
+        name: "maxShares",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "owner",
+        type: "address"
+      }
+    ],
+    name: "maxRedeem",
+    outputs: [
+      {
+        name: "maxShares",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "owner",
+        type: "address"
+      }
+    ],
+    name: "maxWithdraw",
+    outputs: [
+      {
+        name: "maxAssets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      },
+      {
+        name: "receiver",
+        type: "address"
+      }
+    ],
+    name: "mint",
+    outputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "nonpayable",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    name: "previewDeposit",
+    outputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    name: "previewMint",
+    outputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    name: "previewRedeem",
+    outputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    name: "previewWithdraw",
+    outputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      },
+      {
+        name: "receiver",
+        type: "address"
+      },
+      {
+        name: "owner",
+        type: "address"
+      }
+    ],
+    name: "redeem",
+    outputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "nonpayable",
+    type: "function"
+  },
+  {
+    inputs: [],
+    name: "totalAssets",
+    outputs: [
+      {
+        name: "totalManagedAssets",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [],
+    name: "totalSupply",
+    outputs: [{ type: "uint256" }],
+    stateMutability: "view",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "to",
+        type: "address"
+      },
+      {
+        name: "amount",
+        type: "uint256"
+      }
+    ],
+    name: "transfer",
+    outputs: [{ type: "bool" }],
+    stateMutability: "nonpayable",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "from",
+        type: "address"
+      },
+      {
+        name: "to",
+        type: "address"
+      },
+      {
+        name: "amount",
+        type: "uint256"
+      }
+    ],
+    name: "transferFrom",
+    outputs: [{ type: "bool" }],
+    stateMutability: "nonpayable",
+    type: "function"
+  },
+  {
+    inputs: [
+      {
+        name: "assets",
+        type: "uint256"
+      },
+      {
+        name: "receiver",
+        type: "address"
+      },
+      {
+        name: "owner",
+        type: "address"
+      }
+    ],
+    name: "withdraw",
+    outputs: [
+      {
+        name: "shares",
+        type: "uint256"
+      }
+    ],
+    stateMutability: "nonpayable",
+    type: "function"
+  }
+];
+function erc(config = {}) {
+  const standards = {
+    20: true,
+    721: true,
+    4626: false,
+    ...config
+  };
+  return {
+    contracts() {
+      const contracts = [];
+      if (standards[20])
+        contracts.push({
+          name: "ERC20",
+          abi: erc20ABI
+        });
+      if (standards[721])
+        contracts.push({
+          name: "ERC721",
+          abi: erc721ABI
+        });
+      if (standards[4626])
+        contracts.push({
+          name: "ERC4626",
+          abi: erc4626ABI
+        });
+      return contracts;
+    },
+    name: "ERC"
+  };
+}
+
+// src/plugins/etherscan.ts
+var apiUrls = {
+  [1]: "https://api.etherscan.io/api",
+  [5]: "https://api-goerli.etherscan.io/api",
+  [11155111]: "https://api-sepolia.etherscan.io/api",
+  [10]: "https://api-optimistic.etherscan.io/api",
+  [420]: "https://api-goerli-optimistic.etherscan.io/api",
+  [137]: "https://api.polygonscan.com/api",
+  [80001]: "https://api-testnet.polygonscan.com/api",
+  [42161]: "https://api.arbiscan.io/api",
+  [421613]: "https://api-goerli.arbiscan.io/api",
+  [56]: "https://api.bscscan.com/api",
+  [97]: "https://api-testnet.bscscan.com/api",
+  [128]: "https://api.hecoinfo.com/api",
+  [256]: "https://api-testnet.hecoinfo.com/api",
+  [250]: "https://api.ftmscan.com/api",
+  [4002]: "https://api-testnet.ftmscan.com/api",
+  [43114]: "https://api.snowtrace.io/api",
+  [43113]: "https://api-testnet.snowtrace.io/api",
+  [42220]: "https://api.celoscan.io/api",
+  [44787]: "https://api-alfajores.celoscan.io/api"
+};
+function etherscan({
+  apiKey,
+  cacheDuration,
+  chainId,
+  contracts: contracts_
+}) {
+  const contracts = contracts_.map((x) => ({
+    ...x,
+    address: typeof x.address === "string" ? { [chainId]: x.address } : x.address
+  }));
+  return blockExplorer({
+    apiKey,
+    baseUrl: apiUrls[chainId],
+    cacheDuration,
+    contracts,
+    getAddress({ address }) {
+      if (!address)
+        throw new Error("address is required");
+      if (typeof address === "string")
+        return address;
+      const contractAddress = address[chainId];
+      if (!contractAddress)
+        throw new Error(
+          `No address found for chainId "${chainId}". Make sure chainId "${chainId}" is set as an address.`
+        );
+      return contractAddress;
+    },
+    name: "Etherscan"
+  });
+}
+
+// src/plugins/foundry.ts
+import dedent2 from "dedent";
+import { execa, execaCommandSync } from "execa";
+import { default as fse2 } from "fs-extra";
+import { globby } from "globby";
+import { basename, extname, join as join2, resolve } from "pathe";
+import pc from "picocolors";
+import { z as z2 } from "zod";
+var defaultExcludes = [
+  "Common.sol/**",
+  "Components.sol/**",
+  "Script.sol/**",
+  "StdAssertions.sol/**",
+  "StdInvariant.sol/**",
+  "StdError.sol/**",
+  "StdCheats.sol/**",
+  "StdMath.sol/**",
+  "StdJson.sol/**",
+  "StdStorage.sol/**",
+  "StdUtils.sol/**",
+  "Vm.sol/**",
+  "console.sol/**",
+  "console2.sol/**",
+  "test.sol/**",
+  "**.s.sol/*.json",
+  "**.t.sol/*.json"
+];
+var FoundryConfigSchema = z2.object({
+  out: z2.string().default("out"),
+  src: z2.string().default("src")
+});
+function foundry({
+  artifacts,
+  deployments = {},
+  exclude = defaultExcludes,
+  forge: {
+    clean = false,
+    build = true,
+    path: forgeExecutable = "forge",
+    rebuild = true
+  } = {},
+  include = ["*.json"],
+  namePrefix = "",
+  project: project_
+} = {}) {
+  function getContractName(artifactPath, usePrefix = true) {
+    const filename = basename(artifactPath);
+    const extension = extname(artifactPath);
+    return `${usePrefix ? namePrefix : ""}${filename.replace(extension, "")}`;
+  }
+  async function getContract(artifactPath) {
+    const artifact = await fse2.readJSON(artifactPath);
+    return {
+      abi: artifact.abi,
+      address: deployments[getContractName(artifactPath, false)],
+      name: getContractName(artifactPath)
+    };
+  }
+  async function getArtifactPaths(artifactsDirectory2) {
+    return await globby([
+      ...include.map((x) => `${artifactsDirectory2}/**/${x}`),
+      ...exclude.map((x) => `!${artifactsDirectory2}/**/${x}`)
+    ]);
+  }
+  const project = resolve(process.cwd(), project_ ?? "");
+  let config = {
+    out: "out",
+    src: "src"
+  };
+  try {
+    config = FoundryConfigSchema.parse(
+      JSON.parse(
+        execaCommandSync(`${forgeExecutable} config --json --root ${project}`).stdout
+      )
+    );
+  } catch {
+  } finally {
+    config = {
+      ...config,
+      out: artifacts ?? config.out
+    };
+  }
+  const artifactsDirectory = join2(project, config.out);
+  return {
+    async contracts() {
+      if (clean)
+        await execa(forgeExecutable, ["clean", "--root", project]);
+      if (build)
+        await execa(forgeExecutable, ["build", "--root", project]);
+      if (!fse2.pathExistsSync(artifactsDirectory))
+        throw new Error("Artifacts not found.");
+      const artifactPaths = await getArtifactPaths(artifactsDirectory);
+      const contracts = [];
+      for (const artifactPath of artifactPaths) {
+        const contract = await getContract(artifactPath);
+        if (!contract.abi?.length)
+          continue;
+        contracts.push(contract);
+      }
+      return contracts;
+    },
+    name: "Foundry",
+    async validate() {
+      if (!await fse2.pathExists(project))
+        throw new Error(`Foundry project ${pc.gray(project_)} not found.`);
+      if (clean || build || rebuild)
+        try {
+          await execa(forgeExecutable, ["--version"]);
+        } catch (_error) {
+          throw new Error(dedent2`
+            forge must be installed to use Foundry plugin.
+            To install, follow the instructions at https://book.getfoundry.sh/getting-started/installation
+          `);
+        }
+    },
+    watch: {
+      command: rebuild ? async () => {
+        log(
+          `${pc.magenta("Foundry")} Watching project at ${pc.gray(
+            project
+          )}`
+        );
+        const subprocess = execa(forgeExecutable, [
+          "build",
+          "--watch",
+          "--root",
+          project
+        ]);
+        subprocess.stdout?.on("data", (data) => {
+          process.stdout.write(`${pc.magenta("Foundry")} ${data}`);
+        });
+        process.once("SIGINT", shutdown);
+        process.once("SIGTERM", shutdown);
+        function shutdown() {
+          subprocess?.cancel();
+        }
+      } : void 0,
+      paths: [
+        ...include.map((x) => `${artifactsDirectory}/**/${x}`),
+        ...exclude.map((x) => `!${artifactsDirectory}/**/${x}`)
+      ],
+      async onAdd(path) {
+        return getContract(path);
+      },
+      async onChange(path) {
+        return getContract(path);
+      },
+      async onRemove(path) {
+        return getContractName(path);
+      }
+    }
+  };
+}
+
+// src/plugins/hardhat.ts
+import dedent3 from "dedent";
+import { execa as execa2 } from "execa";
+import { default as fse3 } from "fs-extra";
+import { globby as globby2 } from "globby";
+import { basename as basename2, extname as extname2, join as join3, resolve as resolve2 } from "pathe";
+import pc2 from "picocolors";
+var defaultExcludes2 = ["build-info/**", "*.dbg.json"];
+function hardhat({
+  artifacts = "artifacts",
+  deployments = {},
+  exclude = defaultExcludes2,
+  commands = {},
+  include = ["*.json"],
+  namePrefix = "",
+  project: project_,
+  sources = "contracts"
+}) {
+  function getContractName(artifact) {
+    return `${namePrefix}${artifact.contractName}`;
+  }
+  async function getContract(artifactPath) {
+    const artifact = await fse3.readJSON(artifactPath);
+    return {
+      abi: artifact.abi,
+      address: deployments[artifact.contractName],
+      name: getContractName(artifact)
+    };
+  }
+  async function getArtifactPaths(artifactsDirectory2) {
+    return await globby2([
+      ...include.map((x) => `${artifactsDirectory2}/**/${x}`),
+      ...exclude.map((x) => `!${artifactsDirectory2}/**/${x}`)
+    ]);
+  }
+  const project = resolve2(process.cwd(), project_);
+  const artifactsDirectory = join3(project, artifacts);
+  const sourcesDirectory = join3(project, sources);
+  const { build = true, clean = false, rebuild = true } = commands;
+  return {
+    async contracts() {
+      if (clean) {
+        const packageManager = await getPackageManager(true);
+        const [command, ...options] = (typeof clean === "boolean" ? `${packageManager} hardhat clean` : clean).split(" ");
+        await execa2(command, options, { cwd: project });
+      }
+      if (build) {
+        const packageManager = await getPackageManager(true);
+        const [command, ...options] = (typeof build === "boolean" ? `${packageManager} hardhat compile` : build).split(" ");
+        await execa2(command, options, { cwd: project });
+      }
+      if (!fse3.pathExistsSync(artifactsDirectory))
+        throw new Error("Artifacts not found.");
+      const artifactPaths = await getArtifactPaths(artifactsDirectory);
+      const contracts = [];
+      for (const artifactPath of artifactPaths) {
+        const contract = await getContract(artifactPath);
+        if (!contract.abi?.length)
+          continue;
+        contracts.push(contract);
+      }
+      return contracts;
+    },
+    name: "Hardhat",
+    async validate() {
+      if (!await fse3.pathExists(project))
+        throw new Error(`Hardhat project ${pc2.gray(project)} not found.`);
+      const packageName = "hardhat";
+      const isPackageInstalled = await getIsPackageInstalled({
+        packageName,
+        cwd: project
+      });
+      if (isPackageInstalled)
+        return;
+      const [packageManager, command] = await getInstallCommand(packageName);
+      throw new Error(dedent3`
+        ${packageName} must be installed to use Hardhat plugin.
+        To install, run: ${packageManager} ${command.join(" ")}
+      `);
+    },
+    watch: {
+      command: rebuild ? async () => {
+        log(
+          `${pc2.blue("Hardhat")} Watching project at ${pc2.gray(project)}`
+        );
+        const [command, ...options] = (typeof rebuild === "boolean" ? `${await getPackageManager(true)} hardhat compile` : rebuild).split(" ");
+        const { watch } = await import("chokidar");
+        const watcher = watch(sourcesDirectory, {
+          atomic: true,
+          awaitWriteFinish: true,
+          ignoreInitial: true,
+          persistent: true
+        });
+        watcher.on("all", async (event, path) => {
+          if (event !== "change" && event !== "add" && event !== "unlink")
+            return;
+          log(
+            `${pc2.blue("Hardhat")} Detected ${event} at ${basename2(path)}`
+          );
+          const subprocess = execa2(command, options, {
+            cwd: project
+          });
+          subprocess.stdout?.on("data", (data) => {
+            process.stdout.write(`${pc2.blue("Hardhat")} ${data}`);
+          });
+        });
+        process.once("SIGINT", shutdown);
+        process.once("SIGTERM", shutdown);
+        async function shutdown() {
+          await watcher.close();
+        }
+      } : void 0,
+      paths: [
+        artifactsDirectory,
+        ...include.map((x) => `${artifactsDirectory}/**/${x}`),
+        ...exclude.map((x) => `!${artifactsDirectory}/**/${x}`)
+      ],
+      async onAdd(path) {
+        return getContract(path);
+      },
+      async onChange(path) {
+        return getContract(path);
+      },
+      async onRemove(path) {
+        const filename = basename2(path);
+        const extension = extname2(path);
+        const removedContractName = `${namePrefix}${filename.replace(
+          extension,
+          ""
+        )}`;
+        const artifactPaths = await getArtifactPaths(artifactsDirectory);
+        for (const artifactPath of artifactPaths) {
+          const contract = await getContract(artifactPath);
+          if (contract.name === removedContractName)
+            return;
+        }
+        return removedContractName;
+      }
+    }
+  };
+}
+
+// src/plugins/react.ts
+import { pascalCase as pascalCase2 } from "change-case";
+import dedent4 from "dedent";
+function react(config = {}) {
+  const hooks = {
+    useContractEvent: true,
+    useContractItemEvent: true,
+    useContractRead: true,
+    useContractFunctionRead: true,
+    useContractWrite: true,
+    useContractFunctionWrite: true,
+    usePrepareContractWrite: true,
+    usePrepareContractFunctionWrite: true,
+    ...config
+  };
+  return {
+    name: "React",
+    async run({ contracts, isTypeScript, outputs }) {
+      const imports = /* @__PURE__ */ new Set([]);
+      const actionsImports = /* @__PURE__ */ new Set([]);
+      const hasWriteContractMode = outputs.some(
+        (x) => x.plugin.name === "Actions" && x.imports?.includes("WriteContractMode")
+      );
+      const hookNames = /* @__PURE__ */ new Set();
+      const getHookNameError = (name, contractName) => new Error(
+        `Hook name "${name}" must be unique for contract "${contractName}".`
+      );
+      const content = [];
+      for (const contract of contracts) {
+        const baseHookName = pascalCase2(contract.name);
+        let typeParams = "";
+        let innerContent = "";
+        let omitted = "";
+        const innerHookParams = {
+          abi: contract.meta.abiName
+        };
+        if (contract.meta.addressName) {
+          omitted = `| 'address'`;
+          if (typeof contract.address === "object") {
+            imports.add("Address");
+            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}, address?: Address  }`;
+            if (Object.keys(contract.address).length > 1) {
+              innerHookParams.address = `${contract.meta.addressName}[chainId as keyof typeof ${contract.meta.addressName}]`;
+              imports.add("useNetwork");
+              imports.add("useChainId");
+              innerContent = dedent4`
+                const { chain } = useNetwork()
+                const defaultChainId = useChainId()
+                const chainId = config.chainId ?? chain?.id ?? defaultChainId
+              `;
+            } else
+              innerHookParams.address = `${contract.meta.addressName}[${Object.keys(contract.address)[0]}]`;
+          } else if (contract.address)
+            innerHookParams.address = contract.meta.addressName;
+        }
+        const innerHookConfig = `${Object.entries(innerHookParams).reduce(
+          (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
+          "{"
+        )}...config}`;
+        const genDocString = (hookName, item) => {
+          let description = `Wraps __{@link ${hookName}}__ with \`abi\` set to __{@link ${contract.meta.abiName}}__`;
+          if (item)
+            description += ` and \`${item.name}\` set to \`"${item.value}"\``;
+          if (contract.address) {
+            const docString = getAddressDocString({ address: contract.address });
+            if (docString)
+              return dedent4`
+              /**
+              * ${description}.
+              * 
+              ${docString}
+              */
+              `;
+          }
+          return dedent4`
+          /**
+           * ${description}.
+           */
+          `;
+        };
+        let hasReadFunction = false;
+        let hasWriteFunction = false;
+        let hasEvent = false;
+        for (const component of contract.abi) {
+          if (component.type === "function")
+            if (component.stateMutability === "view" || component.stateMutability === "pure")
+              hasReadFunction = true;
+            else
+              hasWriteFunction = true;
+          else if (component.type === "event")
+            hasEvent = true;
+          if (hasReadFunction && hasWriteFunction && hasEvent)
+            break;
+        }
+        if (hasReadFunction) {
+          if (hooks.useContractRead) {
+            const name = `use${baseHookName}Read`;
+            if (hookNames.has(name))
+              throw getHookNameError(name, contract.name);
+            hookNames.add(name);
+            imports.add("useContractRead");
+            const docString = genDocString("useContractRead");
+            let code;
+            if (isTypeScript) {
+              imports.add("UseContractReadConfig");
+              actionsImports.add("ReadContractResult");
+              code = dedent4`
+              ${docString}
+              export function ${name}<
+                TFunctionName extends string,
+                TSelectData = ReadContractResult<typeof ${contract.meta.abiName}, TFunctionName>
+              >(
+                config: Omit<UseContractReadConfig<typeof ${contract.meta.abiName}, TFunctionName, TSelectData>, 'abi'${omitted}>${typeParams} = {} as any,
+              ) {
+                ${innerContent}
+                return useContractRead(${innerHookConfig} as UseContractReadConfig<typeof ${contract.meta.abiName}, TFunctionName, TSelectData>)
+              }
+              `;
+            } else
+              code = dedent4`
+              ${docString}
+              export function ${name}(config = {}) {
+                ${innerContent}
+                return useContractRead(${innerHookConfig})
+              }
+              `;
+            content.push(code);
+          }
+          if (hooks.useContractFunctionRead) {
+            const contractNames = /* @__PURE__ */ new Set();
+            for (const item of contract.abi) {
+              if (item.type === "function" && (item.stateMutability === "view" || item.stateMutability === "pure")) {
+                if (contractNames.has(item.name))
+                  continue;
+                contractNames.add(item.name);
+                const name = `use${baseHookName}${pascalCase2(item.name)}`;
+                if (hookNames.has(name))
+                  throw getHookNameError(name, contract.name);
+                hookNames.add(name);
+                const config2 = `${Object.entries({
+                  ...innerHookParams,
+                  functionName: `'${item.name}'`
+                }).reduce(
+                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
+                  "{"
+                )}...config}`;
+                imports.add("useContractRead");
+                const docString = genDocString("useContractRead", {
+                  name: "functionName",
+                  value: item.name
+                });
+                let code;
+                if (isTypeScript) {
+                  imports.add("UseContractReadConfig");
+                  actionsImports.add("ReadContractResult");
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}<
+                    TFunctionName extends '${item.name}',
+                    TSelectData = ReadContractResult<typeof ${contract.meta.abiName}, TFunctionName>
+                  >(
+                    config: Omit<UseContractReadConfig<typeof ${contract.meta.abiName}, TFunctionName, TSelectData>, 'abi'${omitted} | 'functionName'>${typeParams} = {} as any,
+                  ) {
+                    ${innerContent}
+                    return useContractRead(${config2} as UseContractReadConfig<typeof ${contract.meta.abiName}, TFunctionName, TSelectData>)
+                  }
+                  `;
+                } else {
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}(config = {}) {
+                    ${innerContent}
+                    return useContractRead(${config2})
+                  }
+                  `;
+                }
+                content.push(code);
+              }
+            }
+          }
+        }
+        if (hasWriteFunction) {
+          if (hooks.useContractWrite) {
+            const name = `use${baseHookName}Write`;
+            if (hookNames.has(name))
+              throw getHookNameError(name, contract.name);
+            hookNames.add(name);
+            imports.add("useContractWrite");
+            const docString = genDocString("useContractWrite");
+            let code;
+            if (isTypeScript) {
+              const hasMultichainAddress = typeof contract.address === "object";
+              const TChainId = hasMultichainAddress ? `TChainId extends number = keyof typeof ${contract.meta.addressName}` : "";
+              let typeParams_ = "";
+              if (TChainId) {
+                imports.add("Address");
+                typeParams_ = "address?: never; chainId?: TChainId;";
+              }
+              imports.add("UseContractWriteConfig");
+              if (!hasWriteContractMode)
+                actionsImports.add("WriteContractMode");
+              actionsImports.add("PrepareWriteContractResult");
+              code = dedent4`
+              ${docString}
+              export function ${name}<
+                TFunctionName extends string,
+                TMode extends WriteContractMode = undefined,
+                ${TChainId}
+              >(
+                config: TMode extends 'prepared'
+                  ? UseContractWriteConfig<
+                      PrepareWriteContractResult<typeof ${contract.meta.abiName}, string>['request']['abi'],
+                      TFunctionName,
+                      TMode
+                    >${TChainId ? " & { address?: Address; chainId?: TChainId; }" : ""}
+                  : UseContractWriteConfig<typeof ${contract.meta.abiName}, TFunctionName, TMode> & {
+                      abi?: never
+                      ${typeParams_}
+                    } = {} as any,
+              ) {
+                ${innerContent}
+                return useContractWrite<typeof ${contract.meta.abiName}, TFunctionName, TMode>(${innerHookConfig} as any)
+              }
+              `;
+            } else
+              code = dedent4`
+              ${docString}
+              export function ${name}(config = {}) {
+                ${innerContent}
+                return useContractWrite(${innerHookConfig})
+              }
+              `;
+            content.push(code);
+          }
+          if (hooks.useContractFunctionWrite) {
+            const contractNames = /* @__PURE__ */ new Set();
+            for (const item of contract.abi) {
+              if (item.type === "function" && (item.stateMutability === "nonpayable" || item.stateMutability === "payable")) {
+                if (contractNames.has(item.name))
+                  continue;
+                contractNames.add(item.name);
+                const name = `use${baseHookName}${pascalCase2(item.name)}`;
+                if (hookNames.has(name))
+                  throw getHookNameError(name, contract.name);
+                hookNames.add(name);
+                const config2 = `${Object.entries({
+                  ...innerHookParams,
+                  functionName: `'${item.name}'`
+                }).reduce(
+                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
+                  "{"
+                )}...config}`;
+                imports.add("useContractWrite");
+                const docString = genDocString("useContractWrite", {
+                  name: "functionName",
+                  value: item.name
+                });
+                let code;
+                if (isTypeScript) {
+                  const hasMultichainAddress = typeof contract.address === "object";
+                  const TChainId = hasMultichainAddress ? `TChainId extends number = keyof typeof ${contract.meta.addressName}` : "";
+                  let preparedTypeParams = `functionName?: '${item.name}'`;
+                  let unpreparedTypeParams = `functionName?: '${item.name}'`;
+                  if (TChainId) {
+                    imports.add("Address");
+                    preparedTypeParams = `address?: Address; chainId?: TChainId; functionName?: '${item.name}'`;
+                    unpreparedTypeParams = `address?: never; chainId?: TChainId; functionName?: '${item.name}'`;
+                  }
+                  imports.add("UseContractWriteConfig");
+                  if (!hasWriteContractMode)
+                    actionsImports.add("WriteContractMode");
+                  actionsImports.add("PrepareWriteContractResult");
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}<
+                    TMode extends WriteContractMode = undefined,
+                    ${TChainId}
+                  >(
+                    config: TMode extends 'prepared'
+                    ? UseContractWriteConfig<
+                      PrepareWriteContractResult<typeof ${contract.meta.abiName}, '${item.name}'>['request']['abi'],
+                      '${item.name}',
+                      TMode
+                      > & {${preparedTypeParams}}
+                    : UseContractWriteConfig<typeof ${contract.meta.abiName}, '${item.name}', TMode> & {
+                        abi?: never
+                        ${unpreparedTypeParams}
+                      } = {} as any,
+                  ) {
+                    ${innerContent}
+                    return useContractWrite<typeof ${contract.meta.abiName}, '${item.name}', TMode>(${config2} as any)
+                  }
+                  `;
+                } else {
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}(config = {}) {
+                    ${innerContent}
+                    return useContractWrite(${config2})
+                  }
+                  `;
+                }
+                content.push(code);
+              }
+            }
+          }
+          if (hooks.usePrepareContractWrite) {
+            const name = `usePrepare${baseHookName}Write`;
+            if (hookNames.has(name))
+              throw getHookNameError(name, contract.name);
+            hookNames.add(name);
+            imports.add("usePrepareContractWrite");
+            const docString = genDocString("usePrepareContractWrite");
+            let code;
+            if (isTypeScript) {
+              imports.add("UsePrepareContractWriteConfig");
+              code = dedent4`
+              ${docString}
+              export function ${name}<
+                TFunctionName extends string,
+              >(
+                config: Omit<UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, TFunctionName>, 'abi'${omitted}>${typeParams} = {} as any,
+              ) {
+                ${innerContent}
+                return usePrepareContractWrite(${innerHookConfig} as UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, TFunctionName>)
+              }
+              `;
+            } else
+              code = dedent4`
+              ${docString}
+              export function ${name}(config = {}) {
+                ${innerContent}
+                return usePrepareContractWrite(${innerHookConfig})
+              }
+              `;
+            content.push(code);
+          }
+          if (hooks.usePrepareContractFunctionWrite) {
+            const contractNames = /* @__PURE__ */ new Set();
+            for (const item of contract.abi) {
+              if (item.type === "function" && (item.stateMutability === "nonpayable" || item.stateMutability === "payable")) {
+                if (contractNames.has(item.name))
+                  continue;
+                contractNames.add(item.name);
+                const name = `usePrepare${baseHookName}${pascalCase2(item.name)}`;
+                if (hookNames.has(name))
+                  throw getHookNameError(name, contract.name);
+                hookNames.add(name);
+                const config2 = `${Object.entries({
+                  ...innerHookParams,
+                  functionName: `'${item.name}'`
+                }).reduce(
+                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
+                  "{"
+                )}...config}`;
+                imports.add("usePrepareContractWrite");
+                const docString = genDocString("usePrepareContractWrite", {
+                  name: "functionName",
+                  value: item.name
+                });
+                let code;
+                if (isTypeScript) {
+                  imports.add("UsePrepareContractWriteConfig");
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}(
+                    config: Omit<UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, '${item.name}'>, 'abi'${omitted} | 'functionName'>${typeParams} = {} as any,
+                  ) {
+                    ${innerContent}
+                    return usePrepareContractWrite(${config2} as UsePrepareContractWriteConfig<typeof ${contract.meta.abiName}, '${item.name}'>)
+                  }
+                  `;
+                } else {
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}(config = {}) {
+                    ${innerContent}
+                    return usePrepareContractWrite(${config2})
+                  }
+                  `;
+                }
+                content.push(code);
+              }
+            }
+          }
+        }
+        if (hasEvent) {
+          if (hooks.useContractEvent) {
+            const name = `use${baseHookName}Event`;
+            if (hookNames.has(name))
+              throw getHookNameError(name, contract.name);
+            hookNames.add(name);
+            imports.add("useContractEvent");
+            const docString = genDocString("useContractEvent");
+            let code;
+            if (isTypeScript) {
+              imports.add("UseContractEventConfig");
+              code = dedent4`
+              ${docString}
+              export function ${name}<
+                TEventName extends string,
+              >(
+                config: Omit<UseContractEventConfig<typeof ${contract.meta.abiName}, TEventName>, 'abi'${omitted}>${typeParams} = {} as any,
+              ) {
+                ${innerContent}
+                return useContractEvent(${innerHookConfig} as UseContractEventConfig<typeof ${contract.meta.abiName}, TEventName>)
+              }
+              `;
+            } else
+              code = dedent4`
+              ${docString}
+              export function ${name}(config = {}) {
+                ${innerContent}
+                return useContractEvent(${innerHookConfig})
+              }
+              `;
+            content.push(code);
+          }
+          if (hooks.useContractItemEvent) {
+            const contractNames = /* @__PURE__ */ new Set();
+            for (const item of contract.abi) {
+              if (item.type === "event") {
+                if (contractNames.has(item.name))
+                  continue;
+                contractNames.add(item.name);
+                const name = `use${baseHookName}${pascalCase2(item.name)}Event`;
+                if (hookNames.has(name))
+                  throw getHookNameError(name, contract.name);
+                hookNames.add(name);
+                const config2 = `${Object.entries({
+                  ...innerHookParams,
+                  eventName: `'${item.name}'`
+                }).reduce(
+                  (prev, curr) => `${prev}${curr[0]}: ${curr[1]},`,
+                  "{"
+                )}...config}`;
+                imports.add("useContractEvent");
+                const docString = genDocString("useContractEvent", {
+                  name: "eventName",
+                  value: item.name
+                });
+                let code;
+                if (isTypeScript) {
+                  imports.add("UseContractEventConfig");
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}(
+                    config: Omit<UseContractEventConfig<typeof ${contract.meta.abiName}, '${item.name}'>, 'abi'${omitted} | 'eventName'>${typeParams} = {} as any,
+                  ) {
+                    ${innerContent}
+                    return useContractEvent(${config2} as UseContractEventConfig<typeof ${contract.meta.abiName}, '${item.name}'>)
+                  }
+                  `;
+                } else {
+                  code = dedent4`
+                  ${docString}
+                  export function ${name}(config = {}) {
+                    ${innerContent}
+                    return useContractEvent(${config2})
+                  }
+                  `;
+                }
+                content.push(code);
+              }
+            }
+          }
+        }
+      }
+      const importValues = [...imports.values()];
+      const actionsImportValues = [...actionsImports.values()];
+      return {
+        imports: (importValues.length ? `import { ${importValues.join(", ")} } from 'wagmi'
+` : "") + (actionsImportValues.length ? `import { ${actionsImportValues.join(
+          ", "
+        )} } from 'wagmi/actions'` : ""),
+        content: content.join("\n\n")
+      };
+    }
+  };
+}
+
+// src/plugins/sourcify.ts
+import { Abi as AbiSchema } from "abitype/zod";
+import { z as z3 } from "zod";
+var SourcifyResponse = z3.object({
+  compiler: z3.object({
+    version: z3.string()
+  }),
+  language: z3.string(),
+  output: z3.object({
+    abi: AbiSchema,
+    devdoc: z3.any(),
+    userdoc: z3.any()
+  }),
+  settings: z3.any(),
+  sources: z3.any(),
+  version: z3.number()
+});
+function sourcify({
+  cacheDuration,
+  chainId,
+  contracts: contracts_
+}) {
+  const contracts = contracts_.map((x) => ({
+    ...x,
+    address: typeof x.address === "string" ? { [chainId]: x.address } : x.address
+  }));
+  return fetch({
+    cacheDuration,
+    contracts,
+    async parse({ response }) {
+      if (response.status === 404)
+        throw new Error("Contract not found in Sourcify repository.");
+      const json = await response.json();
+      const parsed = await SourcifyResponse.safeParseAsync(json);
+      if (!parsed.success)
+        throw fromZodError(parsed.error, { prefix: "Invalid response" });
+      if (parsed.data.output.abi)
+        return parsed.data.output.abi;
+      throw new Error("contract not found");
+    },
+    request({ address }) {
+      if (!address)
+        throw new Error("address is required");
+      let contractAddress;
+      if (typeof address === "string")
+        contractAddress = address;
+      if (typeof address === "object")
+        contractAddress = address[chainId];
+      if (!contractAddress)
+        throw new Error(
+          `No address found for chainId "${chainId}". Make sure chainId "${chainId}" is set as an address.`
+        );
+      return {
+        url: `https://repo.sourcify.dev/contracts/full_match/${chainId}/${contractAddress}/metadata.json`
+      };
+    }
+  });
+}
+export {
+  actions,
+  blockExplorer,
+  erc,
+  etherscan,
+  fetch,
+  foundry,
+  hardhat,
+  react,
+  sourcify
+};
diff --git a/node_modules/@wagmi/cli/dist/plugins/index.js.rej b/node_modules/@wagmi/cli/dist/plugins/index.js.rej
new file mode 100644
index 0000000..9a44be7
--- /dev/null
+++ b/node_modules/@wagmi/cli/dist/plugins/index.js.rej
@@ -0,0 +1,18 @@
+@@ -46,7 +46,7 @@
+         if (contract.meta.addressName) {
+           omitted = `| 'address'`;
+           if (typeof contract.address === "object") {
+-            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName} }`;
++            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}, address?: Address  }`;
+             if (Object.keys(contract.address).length > 1) {
+               innerActionParams.address = `${contract.meta.addressName}[config.chainId as keyof typeof ${contract.meta.addressName}]`;
+             } else
+@@ -1764,7 +1764,7 @@
+         if (contract.meta.addressName) {
+           omitted = `| 'address'`;
+           if (typeof contract.address === "object") {
+-            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}  }`;
++            typeParams = `& { chainId?: keyof typeof ${contract.meta.addressName}, address?: Address  }`;
+             if (Object.keys(contract.address).length > 1) {
+               innerHookParams.address = `${contract.meta.addressName}[chainId as keyof typeof ${contract.meta.addressName}]`;
+               imports.add("useNetwork");
